# PROJEKT LOCAL-GPT - Lokalny Asystent AI

# Klon ChatGPT działający w przeglądarce z WebLLM i IndexedDB

## OPIS PROJEKTU

Local-GPT to aplikacja webowa będąca klonem ChatGPT, która działa w 100% lokalnie w przeglądarce.
Wykorzystuje WebLLM dla modelu AI i IndexedDB dla trwałej pamięci, zapewniając prywatność,
darmowe użytkowanie i pracę offline.

## SENIOR-LEVEL DEVELOPMENT PRACTICES

### Architektura Komponentów

- **Single Responsibility Principle** - każdy komponent ma jedną odpowiedzialność
- **Composition over Inheritance** - komponenty składane z mniejszych części
- **Container/Presentational Pattern** - separacja logiki od UI
- **Custom Hooks** - wydzielenie logiki biznesowej do hooków
- **Proper Error Boundaries** - obsługa błędów na odpowiednim poziomie
- **Performance Optimization** - React.memo, useMemo, useCallback gdzie potrzeba

### Struktura Folderów

```
src/components/
├── feature-name/
│   ├── components/
│   │   ├── SubComponent.tsx
│   │   └── index.ts
│   ├── hooks/
│   │   ├── useFeatureLogic.ts
│   │   └── index.ts
│   ├── types/
│   │   └── index.ts
│   ├── utils/
│   │   └── index.ts
│   ├── FeatureComponent.tsx
│   └── index.ts
```

### Konwencje Komponentów

- **Max 150 linii na komponent** - większe dzielić na mniejsze
- **Props interface nad typem inline** - czytelność i reużywalność
- **Default props przez destructuring** - `{ prop = defaultValue }`
- **Event handlers prefixed** - `handleSomething`, `onSomething`
- **Boolean props prefixed** - `isLoading`, `hasError`, `canEdit`
- **Render functions suffixed** - `renderHeader`, `renderContent`

### Custom Hooks Guidelines

- **Prefix z `use`** - konsystentne nazewnictwo
- **Single concern** - jeden hook = jedna odpowiedzialność
- **Return object dla multiple values** - `{ data, isLoading, error }`
- **Memoization** - używaj useMemo/useCallback dla performance
- **Dependencies arrays** - zawsze kompletne i poprawne

### TypeScript Best Practices

- **Strict mode enabled** - najwyższy poziom typowania
- **Interface over type** - dla object shapes
- **Generic constraints** - `<T extends SomeType>`
- **Utility types** - `Pick`, `Omit`, `Partial`, `Required`
- **Proper return types** - nie rely na inferencji dla public APIs
- **No `any`** - zawsze konkretne typy

## KONWENCJE KODOWANIA

### Język

- **TYLKO ANGIELSKI** w kodzie - wszystkie nazwy zmiennych, funkcji, komentarze, stringi
- Interfejs użytkownika może być po polsku, ale kod tylko po angielsku
- Konsystentna nomenclatura w całym projekcie

### React Patterns

- **Functional components only** - no class components
- **Hooks first** - custom hooks dla logiki biznesowej
- **Error boundaries** - na poziomie feature i app
- **Suspense boundaries** - dla lazy loading
- **Portal usage** - dla modali i tooltipów
- **Forward refs** - dla reusable input components

### State Management

- **Local state first** - useState for component state
- **Custom hooks** - dla shared state logic
- **Context sparingly** - tylko dla truly global state
- **Reducer pattern** - dla complex state logic
- **Optimistic updates** - dla lepszego UX

### Performance

- **React.memo** - dla expensive renders
- **useMemo** - dla expensive calculations
- **useCallback** - dla stable function references
- **Lazy loading** - dla route-based code splitting
- **Virtual scrolling** - dla długich list
- **Image optimization** - proper loading strategies

### Styling

- **Tailwind CSS classes** - utility-first approach
- **Shadcn/ui components** - consistent design system
- **CSS-in-JS sparingly** - tylko gdy Tailwind nie wystarcza
- **Mobile-first approach** - responsive design pattern
- **Design tokens** - consistent spacing, colors, typography

### Testing Strategy

- **Unit tests** - dla utils i pure functions
- **Integration tests** - dla hook interactions
- **Component tests** - React Testing Library
- **E2E tests** - dla critical user flows
- **Visual regression** - dla UI consistency

## STRUKTURA PLIKÓW

### Component Organization

```
src/components/chat/
├── interface/
│   ├── components/
│   │   ├── ChatGuard.tsx
│   │   └── index.ts
│   ├── hooks/
│   │   ├── useChatGuard.ts
│   │   └── index.ts
│   ├── ChatInterface.tsx
│   └── index.ts
├── header/
│   ├── components/
│   │   ├── BreadcrumbNavigation.tsx
│   │   ├── ActionButtons.tsx
│   │   └── index.ts
│   ├── hooks/
│   │   ├── useHeaderActions.ts
│   │   └── index.ts
│   ├── ChatHeader.tsx
│   └── index.ts
```

### Hook Organization

```
src/hooks/
├── api/
│   ├── useConversations.ts
│   ├── useMessages.ts
│   └── index.ts
├── ui/
│   ├── useKeyboardShortcuts.ts
│   ├── useToast.ts
│   └── index.ts
├── business/
│   ├── useChatLogic.ts
│   ├── useConversationManagement.ts
│   └── index.ts
```

## STOS TECHNOLOGICZNY

- **Frontend**: Vite + React 18 + TypeScript
- **UI Library**: Shadcn/ui + Tailwind CSS + Radix UI
- **Routing**: react-router-dom
- **State**: React hooks + Context (sparingly)
- **Lokalne AI**: @mlc-ai/web-llm
- **Baza Danych**: Dexie.js (wrapper na IndexedDB)
- **Testing**: Vitest + React Testing Library + Playwright
- **Linting**: ESLint + Prettier + TypeScript strict

## ARCHITEKTURA BAZY DANYCH (IndexedDB przez Dexie.js)

### Tabela: conversations

- id: string (UUID, primary key)
- title: string (tytuł rozmowy)
- messages: IMessage[] (embedded documents)
- pinned: boolean
- createdAt: Date
- updatedAt: Date
- userId?: string (dla zalogowanych użytkowników)

### Tabela: documents

- id: number (primary key, auto-increment)
- filename: string
- content: string
- createdAt: Date
- fileType: 'txt' | 'md' | 'pdf'

## QUALITY GATES

### Code Review Checklist

- [ ] Single responsibility per component/hook
- [ ] Proper TypeScript typing (no `any`)
- [ ] Performance optimizations where needed
- [ ] Accessibility compliance (WCAG 2.1)
- [ ] Mobile responsiveness
- [ ] Error handling implemented
- [ ] Loading states handled
- [ ] Tests written and passing
- [ ] No console errors or warnings
- [ ] Consistent naming conventions

### Performance Targets

- [ ] Bundle size < 2MB
- [ ] First Contentful Paint < 1.5s
- [ ] Largest Contentful Paint < 2.5s
- [ ] Cumulative Layout Shift < 0.1
- [ ] First Input Delay < 100ms

### Accessibility Targets

- [ ] Keyboard navigation support
- [ ] Screen reader compatibility
- [ ] Color contrast compliance
- [ ] Focus management
- [ ] ARIA labels where needed

## METRYKI SUKCESU MVP

- [x] Użytkownik może napisać wiadomość i otrzymać odpowiedź
- [x] Historia rozmów jest zachowana po odświeżeniu
- [x] Można tworzyć nowe rozmowy
- [ ] Można załączyć plik .txt/.md i AI odpowiada na jego podstawie
- [x] UI jest responsywne i profesjonalne
- [x] Aplikacja działa offline
- [x] Smooth animations i transitions
- [x] Chat filtering i search
- [x] Chat management (pin, rename, delete)

## DEVELOPMENT WORKFLOW

1. **Feature Planning** - wireframes + technical design
2. **Component Breakdown** - identify reusable pieces
3. **Hook Design** - plan state management strategy
4. **TDD Approach** - write tests first for complex logic
5. **Progressive Enhancement** - start with basic functionality
6. **Performance Optimization** - measure and optimize
7. **Accessibility Testing** - keyboard and screen reader testing
8. **Code Review** - peer review against quality gates

## UWAGI DLA SENIOR DEVELOPERA

1. **Composition Pattern** - prefer composition over large monolithic components
2. **Performance First** - measure before optimizing, but think about it early
3. **Accessibility by Design** - not an afterthought
4. **Error Boundaries** - fail gracefully, inform users appropriately
5. **Type Safety** - leverage TypeScript's power fully
6. **Testing Strategy** - test behavior, not implementation
7. **Code Reusability** - abstract common patterns into hooks/utils
8. **Documentation** - code should be self-documenting with proper naming
9. **Progressive Enhancement** - work offline, sync when online
10. **User Experience** - every interaction should feel smooth and predictable

Pamiętaj: "Make it work, make it right, make it fast" - w tej kolejności!
